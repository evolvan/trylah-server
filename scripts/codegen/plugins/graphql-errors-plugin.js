"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.ERROR_INTERFACE_NAME = void 0;
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const graphql_1 = require("graphql");
// This plugin generates classes for all GraphQL types which implement the `ErrorResult` interface.
// This means that when returning an error result from a GraphQL operation, you can use one of
// the generated classes rather than constructing the object by hand.
// It also generates type resolvers to be used by Apollo Server to discriminate between
// members of returned union types.
exports.ERROR_INTERFACE_NAME = 'ErrorResult';
const empty = () => '';
const errorsVisitor = {
    NonNullType(node) {
        return node.type.kind === 'NamedType'
            ? node.type.name.value
            : node.type.kind === 'ListType'
                ? node.type
                : '';
    },
    FieldDefinition(node) {
        const type = (node.type.kind === 'ListType'
            ? node.type.type
            : node.type);
        const tsType = isScalar(type) ? `Scalars['${type}']` : 'any';
        const listPart = node.type.kind === 'ListType' ? `[]` : ``;
        return `${node.name.value}: ${tsType}${listPart}`;
    },
    ScalarTypeDefinition: empty,
    InputObjectTypeDefinition: empty,
    EnumTypeDefinition: empty,
    UnionTypeDefinition: empty,
    InterfaceTypeDefinition(node) {
        if (node.name.value !== exports.ERROR_INTERFACE_NAME) {
            return '';
        }
        return [
            `export class ${exports.ERROR_INTERFACE_NAME} {`,
            `  readonly __typename: string;`,
            `  readonly errorCode: string;`,
            ...node.fields
                .filter(f => !f.includes('errorCode:'))
                .map(f => `${f};`),
            `}`,
        ].join('\n');
    },
    ObjectTypeDefinition(node, key, parent) {
        if (!inheritsFromErrorResult(node)) {
            return '';
        }
        const originalNode = parent[key];
        return [
            `export class ${node.name.value} extends ${exports.ERROR_INTERFACE_NAME} {`,
            `  readonly __typename = '${node.name.value}';`,
            // We cast this to "any" otherwise we need to specify it as type "ErrorCode",
            // which means shared ErrorResult classes e.g. OrderStateTransitionError
            // will not be compatible between the admin and shop variations.
            `  readonly errorCode = '${camelToUpperSnakeCase(node.name.value)}' as any;`,
            `  readonly message = '${camelToUpperSnakeCase(node.name.value)}';`,
            `  constructor(`,
            ...node.fields
                .filter(f => !f.includes('errorCode:') &&
                !f.includes('message:'))
                .map(f => `    public ${f},`),
            `  ) {`,
            `    super();`,
            `  }`,
            `}`,
        ].join('\n');
    },
};
const plugin = (schema, documents, config, info) => {
    const printedSchema = (0, graphql_1.printSchema)(schema); // Returns a string representation of the schema
    const astNode = (0, graphql_1.parse)(printedSchema); // Transforms the string into ASTNode
    const result = (0, graphql_1.visit)(astNode, { leave: errorsVisitor });
    const defs = result.definitions
        .filter(d => !!d)
        // Ensure the ErrorResult base class is first
        .sort((a, b) => (a.includes('class ErrorResult') ? -1 : 1));
    return {
        content: [
            `/** This file was generated by the graphql-errors-plugin, which is part of the "codegen" npm script. */`,
            generateScalars(schema, config),
            ...defs,
            defs.length ? generateIsErrorFunction(schema) : '',
            generateTypeResolvers(schema),
        ].join('\n\n'),
    };
};
exports.plugin = plugin;
function generateScalars(schema, config) {
    const scalarMap = (0, visitor_plugin_common_1.buildScalars)(schema, config.scalars);
    const allScalars = Object.keys(scalarMap)
        .map(scalarName => {
        const scalarValue = scalarMap[scalarName].type;
        const scalarType = schema.getType(scalarName);
        return `  ${scalarName}: ${scalarValue};`;
    })
        .join('\n');
    return `export type Scalars = {\n${allScalars}\n};`;
}
function generateErrorClassSource(node) {
    let source = `export class ${node.name.value} {`;
    for (const field of node.fields) {
        source += `  ${1}`;
    }
}
function generateIsErrorFunction(schema) {
    const errorNodes = Object.values(schema.getTypeMap())
        .map(type => type.astNode)
        .filter(isObjectTypeDefinition)
        .filter(node => inheritsFromErrorResult(node));
    return `
const errorTypeNames = new Set([${errorNodes.map(n => `'${n.name.value}'`).join(', ')}]);
function isGraphQLError(input: any): input is import('@vendure/common/lib/generated-types').${exports.ERROR_INTERFACE_NAME} {
  return input instanceof ${exports.ERROR_INTERFACE_NAME} || errorTypeNames.has(input.__typename);
}`;
}
function generateTypeResolvers(schema) {
    const mutations = getOperationsThatReturnErrorUnions(schema, schema.getMutationType().getFields());
    const queries = getOperationsThatReturnErrorUnions(schema, schema.getQueryType().getFields());
    const operations = [...mutations, ...queries];
    const varName = isAdminApi(schema)
        ? `adminErrorOperationTypeResolvers`
        : `shopErrorOperationTypeResolvers`;
    const result = [`export const ${varName} = {`];
    const typesHandled = new Set();
    for (const operation of operations) {
        const returnType = unwrapType(operation.type);
        if (!typesHandled.has(returnType.name)) {
            typesHandled.add(returnType.name);
            const nonErrorResult = returnType
                .getTypes()
                .find(t => !inheritsFromErrorResult(t));
            result.push(`  ${returnType.name}: {`, `    __resolveType(value: any) {`, 
            // tslint:disable-next-line:no-non-null-assertion
            `      return isGraphQLError(value) ? (value as any).__typename : '${nonErrorResult.name}';`, `    },`, `  },`);
        }
    }
    result.push(`};`);
    return result.join('\n');
}
function getOperationsThatReturnErrorUnions(schema, fields) {
    return Object.values(fields).filter(operation => {
        var _a;
        const innerType = unwrapType(operation.type);
        if (((_a = innerType.astNode) === null || _a === void 0 ? void 0 : _a.kind) === 'UnionTypeDefinition') {
            return isUnionOfResultAndErrors(schema, innerType.astNode);
        }
        return false;
    });
}
function isUnionOfResultAndErrors(schema, node) {
    const errorResultTypes = node.types.filter(namedType => {
        const type = schema.getType(namedType.name.value);
        if ((0, graphql_1.isObjectType)(type)) {
            if (inheritsFromErrorResult(type)) {
                return true;
            }
        }
        return false;
    });
    return (errorResultTypes.length = node.types.length - 1);
}
function isObjectTypeDefinition(node) {
    return node && (0, graphql_1.isTypeDefinitionNode)(node) && node.kind === 'ObjectTypeDefinition';
}
function inheritsFromErrorResult(node) {
    const interfaceNames = (0, graphql_1.isObjectType)(node)
        ? node.getInterfaces().map(i => i.name)
        : node.interfaces.map(i => i.name.value);
    return interfaceNames.includes(exports.ERROR_INTERFACE_NAME);
}
/**
 * Unwraps the inner type from a higher-order type, e.g. [Address!]! => Address
 */
function unwrapType(type) {
    if ((0, graphql_1.isNamedType)(type)) {
        return type;
    }
    let innerType = type;
    while (!(0, graphql_1.isNamedType)(innerType)) {
        innerType = innerType.ofType;
    }
    return innerType;
}
function isAdminApi(schema) {
    return !!schema.getType('UpdateGlobalSettingsInput');
}
function camelToUpperSnakeCase(input) {
    return input.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
}
function isScalar(type) {
    return [
        'ID',
        'String',
        'Boolean',
        'Int',
        'Float',
        'JSON',
        'DateTime',
        'Upload',
    ].includes(type);
}
//# sourceMappingURL=graphql-errors-plugin.js.map